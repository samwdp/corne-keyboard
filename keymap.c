/*
Copyright 2019 @foostan
Copyright 2020 Drashna Jaelre <@drashna>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include QMK_KEYBOARD_H

#define _WORKMAN 0
#define _QWERTY 1
#define _NUMBERS 2
#define _SYMBOLS 3
#define _ADJUST 4

// for uk kemap KC_HASH is the £ symbol
// for uk kemap KC_BSLS is the # symbol
// for uk kemap KC_NUHS is the # symbol
// ¬ is KC_TILD
// " is KC_AT
// @ is KC_DQUO

// clang-format off
// Tap Dance declarations
enum {
    TD_1_ALT1,
    TD_2_ALT2,
    TD_3_ALT3,
    TD_4_ALT4,
    TD_5_ALT5,
    TD_6_ALT6,
    TD_7_ALT7,
    TD_8_ALT8,
    TD_9_ALT9,
};

// Tap Dance definitions
tap_dance_action_t tap_dance_actions[] = {
    // Tap once for Escape, twice for Caps Lock
    [TD_1_ALT1] = ACTION_TAP_DANCE_DOUBLE(KC_1, LALT(KC_1)),
    [TD_2_ALT2] = ACTION_TAP_DANCE_DOUBLE(KC_2, LALT(KC_2)),
    [TD_3_ALT3] = ACTION_TAP_DANCE_DOUBLE(KC_3, LALT(KC_3)),
    [TD_4_ALT4] = ACTION_TAP_DANCE_DOUBLE(KC_4, LALT(KC_4)),
    [TD_5_ALT5] = ACTION_TAP_DANCE_DOUBLE(KC_5, LALT(KC_5)),
    [TD_6_ALT6] = ACTION_TAP_DANCE_DOUBLE(KC_6, LALT(KC_6)),
    [TD_7_ALT7] = ACTION_TAP_DANCE_DOUBLE(KC_7, LALT(KC_7)),
    [TD_8_ALT8] = ACTION_TAP_DANCE_DOUBLE(KC_8, LALT(KC_8)),
    [TD_9_ALT9] = ACTION_TAP_DANCE_DOUBLE(KC_9, LALT(KC_9)),
};
const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_WORKMAN] = LAYOUT_split_3x6_3(
        KC_NO, KC_Q, KC_D, KC_R, KC_W, KC_B,                                    KC_J, KC_F, KC_U, KC_P, KC_SCLN, KC_EQL, 
        KC_ESC, LSFT_T(KC_A), LALT_T(KC_S), LCTL_T(KC_H), LGUI_T(KC_T), KC_G,   KC_Y, RGUI_T(KC_N), RCTL_T(KC_E), LALT_T(KC_O), RSFT_T(KC_I), KC_QUOT, 
        KC_NO, KC_Z, KC_X, KC_M, KC_C, KC_V,                                    KC_K, KC_L, KC_COMM, KC_DOT, KC_SLSH, KC_ENT, 
        KC_CAPS, LT(_NUMBERS, KC_TAB), LSFT_T(KC_ENT),                          RSFT_T(KC_SPC), LT(_SYMBOLS, KC_BSPC), KC_DEL
    ),

    [_QWERTY] = LAYOUT_split_3x6_3(
        KC_TAB, KC_Q, KC_W, KC_E, KC_R, KC_T,                                   KC_Y, KC_U, KC_I, KC_O, KC_P,KC_BSPC, 
        KC_LCTL, KC_A, KC_S, KC_D, KC_F, KC_G,                                  KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_NO, 
        KC_LSFT, KC_Z, KC_X, KC_C, KC_V, KC_B,                                  KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_NO,
        KC_ESC, LT(_NUMBERS,KC_SPC), KC_RALT,                                   KC_ENT, LT(_SYMBOLS, KC_HOME), KC_INS
    ),

    [_NUMBERS] = LAYOUT_split_3x6_3(
        KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6,                               KC_F7, KC_F8,KC_F9, KC_F10, KC_F11, KC_F12, 
        KC_NO, TD(TD_1_ALT1), TD(TD_2_ALT2), TD(TD_3_ALT3), TD(TD_4_ALT4), TD(TD_5_ALT5),                                    TD(TD_6_ALT6), TD(TD_7_ALT7), TD(TD_8_ALT8), TD(TD_9_ALT9), KC_0, KC_NO, 
        KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,                               KC_LEFT, KC_DOWN, KC_UP, KC_RIGHT, KC_INS, KC_END,
                       KC_TRNS, KC_TRNS, KC_TRNS,                               KC_NO, KC_TRNS, KC_HOME
    ),

    [_SYMBOLS] = LAYOUT_split_3x6_3(
        KC_NO, KC_BSLS, KC_UNDS, KC_EXLM, KC_QUES, KC_PERC,                     KC_CIRC, KC_COLN, KC_EQL, KC_DLR, KC_NO, KC_BSPC, 
        KC_NO, KC_LT, KC_LBRC, KC_LCBR, KC_LPRN, KC_MINS,                       KC_PLUS, KC_RPRN, KC_RCBR, KC_RBRC, KC_GT, KC_NO, 
        KC_NO, KC_NUBS, KC_PIPE, KC_NO, KC_AMPR, KC_SLSH,                       KC_ASTR, KC_AT, KC_QUOT, KC_GRV, KC_EQL, KC_TILD, 
                               KC_TRNS, KC_TRNS, KC_TRNS,                       KC_TRNS, KC_TRNS, KC_TRNS
    ),

    [_ADJUST] = LAYOUT_split_3x6_3(
        KC_NO, KC_NO, KC_MPRV, KC_MPLY, KC_MNXT, KC_MSTP,                       KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, QK_BOOT,
        RGB_TOG, RGB_HUI, RGB_SAI, RGB_VAI, KC_TRNS, TO(_QWERTY),               TO(_WORKMAN), KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
        RGB_MOD, RGB_HUD, RGB_SAD, RGB_VAD, KC_VOLD, KC_VOLU,                   KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO,
        KC_TRNS, KC_TRNS, KC_TRNS,                                              KC_TRNS, KC_TRNS, KC_TRNS),

};

/* status variables */
// clang-format on

uint16_t get_tapping_term(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
  case LALT_T(KC_S):
  case LCTL_T(KC_H):
  case LGUI_T(KC_T):
  case RGUI_T(KC_N):
  case RCTL_T(KC_E):
  case LALT_T(KC_O):
    return TAPPING_TERM + 100;
  case RSFT_T(KC_I):
  case LSFT_T(KC_A):
    return TAPPING_TERM + 200;
  default:
    return TAPPING_TERM;
  }
}

layer_state_t layer_state_set_user(layer_state_t state) {
  return update_tri_layer_state(state, _NUMBERS, _SYMBOLS, _ADJUST);
}

/* 32 * 32 logo */
static void render_logo(void) {
  static const char PROGMEM hexagram_logo[] = {
      0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
      0xc0, 0x70, 0x18, 0x06, 0x06, 0x18, 0x70, 0xc0, 0x80, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07,
      0x1f, 0x32, 0x66, 0xc4, 0x6c, 0x38, 0x1e, 0x37, 0x61, 0xc0, 0x80, 0x80,
      0x80, 0x80, 0xc0, 0x61, 0x37, 0x1e, 0x38, 0x6c, 0xc4, 0x66, 0x32, 0x1f,
      0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80, 0xe0, 0xf8, 0x4c, 0x66, 0x23,
      0x36, 0x1c, 0x78, 0xec, 0x86, 0x03, 0x01, 0x01, 0x01, 0x01, 0x03, 0x86,
      0xec, 0x78, 0x1c, 0x36, 0x23, 0x66, 0x4c, 0xf8, 0xe0, 0x80, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
      0x03, 0x0e, 0x18, 0x60, 0x60, 0x18, 0x0e, 0x03, 0x01, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00};
  oled_write_raw_P(hexagram_logo, sizeof(hexagram_logo));
}

/* KEYBOARD PET START */

/* settings */
#define MIN_WALK_SPEED 10
#define MIN_RUN_SPEED 40

/* advanced settings */
#define ANIM_FRAME_DURATION 200 // how long each frame lasts in ms
#define ANIM_SIZE                                                              \
  96 // number of bytes in array. If you change sprites, minimize for adequate
     // firmware size. max is 1024

/* timers */
uint32_t anim_timer = 0;
uint32_t anim_sleep = 0;

/* current frame */
uint8_t current_frame = 0;

/* status variables */
int current_wpm = 0;
led_t led_usb_state;

bool isSneaking = false;
bool isJumping = false;
bool showedJump = true;
bool isBarking = false;

/* logic */
static void render_luna(int LUNA_X, int LUNA_Y) {
  /* Sit */
  static const char PROGMEM sit[2][ANIM_SIZE] = {
      /* 'sit1', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0xe0, 0x1c, 0x02, 0x05, 0x02, 0x24, 0x04, 0x04,
          0x02, 0xa9, 0x1e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x08, 0x68, 0x10, 0x08,
          0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x06,
          0x82, 0x7c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x0c, 0x10, 0x10, 0x20,
          0x20, 0x20, 0x28, 0x3e, 0x1c, 0x20, 0x20, 0x3e, 0x0f, 0x11, 0x1f,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'sit2', 32x22px */
      {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0x00, 0xe0, 0x1c, 0x02, 0x05, 0x02, 0x24, 0x04, 0x04, 0x02, 0xa9,
       0x1e, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
       0x00, 0xe0, 0x90, 0x08, 0x18, 0x60, 0x10, 0x08, 0x04, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x0e, 0x82, 0x7c, 0x03, 0x00, 0x00,
       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
       0x04, 0x0c, 0x10, 0x10, 0x20, 0x20, 0x20, 0x28, 0x3e, 0x1c, 0x20, 0x20,
       0x3e, 0x0f, 0x11, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

  /* Walk */
  static const char PROGMEM walk[2][ANIM_SIZE] = {
      /* 'walk1', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x90, 0x90,
          0x90, 0xa0, 0xc0, 0x80, 0x80, 0x80, 0x70, 0x08, 0x14, 0x08, 0x90,
          0x10, 0x10, 0x08, 0xa4, 0x78, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0xfc, 0x01, 0x00, 0x00, 0x00,
          0x00, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x08, 0x18, 0xea, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x1c, 0x20, 0x20, 0x3c, 0x0f,
          0x11, 0x1f, 0x03, 0x06, 0x18, 0x20, 0x20, 0x3c, 0x0c, 0x12, 0x1e,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'walk2', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x20, 0x20,
          0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x28, 0x10, 0x20,
          0x20, 0x20, 0x10, 0x48, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x1f, 0x20, 0xf8, 0x02, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
          0x10, 0x30, 0xd5, 0x20, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x20, 0x30, 0x0c, 0x02, 0x05,
          0x09, 0x12, 0x1e, 0x02, 0x1c, 0x14, 0x08, 0x10, 0x20, 0x2c, 0x32,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }};

  /* Run */
  static const char PROGMEM run[2][ANIM_SIZE] = {
      /* 'run1', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0xe0, 0x10, 0x08, 0x08, 0xc8, 0xb0, 0x80,
          0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x40, 0x40, 0x3c, 0x14, 0x04,
          0x08, 0x90, 0x18, 0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x01, 0x02, 0xc4, 0xa4, 0xfc, 0x00, 0x00, 0x00,
          0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x80, 0xc8, 0x58, 0x28, 0x2a, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x0e, 0x09, 0x04, 0x04, 0x04, 0x04, 0x02, 0x03,
          0x02, 0x01, 0x01, 0x02, 0x02, 0x04, 0x08, 0x10, 0x26, 0x2b, 0x32,
          0x04, 0x05, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'run2', 32x22px */
      {
          0x00, 0x00, 0x00, 0xe0, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x78, 0x28, 0x08, 0x10,
          0x20, 0x30, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x01, 0x10, 0xb0, 0x50, 0x55, 0x20, 0x1f, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10,
          0x20, 0x28, 0x37, 0x02, 0x1e, 0x20, 0x20, 0x18, 0x0c, 0x14, 0x1e,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }};

  /* Bark */
  static const char PROGMEM bark[2][ANIM_SIZE] = {
      /* 'bark1', 32x22px */
      {
          0x00, 0xc0, 0x20, 0x10, 0xd0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x80, 0x80, 0x40, 0x3c, 0x14, 0x04, 0x08, 0x90, 0x18,
          0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc8, 0x48,
          0x28, 0x2a, 0x10, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x28,
          0x37, 0x02, 0x02, 0x04, 0x08, 0x10, 0x26, 0x2b, 0x32, 0x04, 0x05,
          0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'bark2', 32x22px */
      {
          0x00, 0xe0, 0x10, 0x10, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x80, 0x80, 0x40, 0x40, 0x2c, 0x14, 0x04, 0x08, 0x90,
          0x18, 0x04, 0x08, 0xb0, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x03, 0x04, 0x08, 0x10, 0x11, 0xf9, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0,
          0x48, 0x28, 0x2a, 0x10, 0x0f, 0x20, 0x4a, 0x09, 0x10, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x0c, 0x10, 0x20, 0x28,
          0x37, 0x02, 0x02, 0x04, 0x08, 0x10, 0x26, 0x2b, 0x32, 0x04, 0x05,
          0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      }};

  /* Sneak */
  static const char PROGMEM sneak[2][ANIM_SIZE] = {
      /* 'sneak1', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x40,
          0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x40, 0x40, 0x80,
          0x00, 0x80, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x1e, 0x21, 0xf0, 0x04, 0x02, 0x02, 0x02, 0x02,
          0x03, 0x02, 0x02, 0x04, 0x04, 0x04, 0x03, 0x01, 0x00, 0x00, 0x09,
          0x01, 0x80, 0x80, 0xab, 0x04, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x03, 0x1c, 0x20, 0x20, 0x3c, 0x0f, 0x11,
          0x1f, 0x02, 0x06, 0x18, 0x20, 0x20, 0x38, 0x08, 0x10, 0x18, 0x04,
          0x04, 0x02, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00,
      },

      /* 'sneak2', 32x22px */
      {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x80,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xa0, 0x20, 0x40,
          0x80, 0xc0, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x3e, 0x41, 0xf0, 0x04, 0x02, 0x02, 0x02, 0x03,
          0x02, 0x02, 0x02, 0x04, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x04,
          0x00, 0x40, 0x40, 0x55, 0x82, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x3f, 0x20, 0x30, 0x0c, 0x02, 0x05, 0x09,
          0x12, 0x1e, 0x04, 0x18, 0x10, 0x08, 0x10, 0x20, 0x28, 0x34, 0x06,
          0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
      }};

  /* animation */
  void animate_luna(void) {
    /* jump */
    if (isJumping || !showedJump) {
      /* clear */
      oled_set_cursor(LUNA_X, LUNA_Y + 2);
      oled_write("     ", false);

      oled_set_cursor(LUNA_X, LUNA_Y - 1);

      showedJump = true;
    } else {
      /* clear */
      oled_set_cursor(LUNA_X, LUNA_Y - 1);
      oled_write("     ", false);

      oled_set_cursor(LUNA_X, LUNA_Y);
    }

    /* switch frame */
    current_frame = (current_frame + 1) % 2;

    /* current status */
    if (led_usb_state.caps_lock) {
      oled_write_raw_P(bark[abs(1 - current_frame)], ANIM_SIZE);

    } else if (isSneaking) {
      oled_write_raw_P(sneak[abs(1 - current_frame)], ANIM_SIZE);

    } else if (current_wpm <= MIN_WALK_SPEED) {
      oled_write_raw_P(sit[abs(1 - current_frame)], ANIM_SIZE);

    } else if (current_wpm <= MIN_RUN_SPEED) {
      oled_write_raw_P(walk[abs(1 - current_frame)], ANIM_SIZE);

    } else {
      oled_write_raw_P(run[abs(1 - current_frame)], ANIM_SIZE);
    }
  }

  /* animation timer */
  if (timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
    anim_timer = timer_read32();
    animate_luna();
  }

  /* this fixes the screen on and off bug */
  if (current_wpm > 0) {
    oled_on();
    anim_sleep = timer_read32();
  } else if (timer_elapsed32(anim_sleep) > OLED_TIMEOUT) {
    /* clear */
    oled_set_cursor(0, 0);
    oled_write("                                                               "
               "                                     ",
               false);
    oled_off();
    oled_set_cursor(LUNA_X, LUNA_Y);
  }
}

/* KEYBOARD PET END */

static void print_logo_narrow(void) {
  render_logo();
  if (current_wpm > 0) {
    anim_sleep = timer_read32();
    /* wpm counter */
    oled_set_cursor(0, 14);
    oled_write(get_u8_str(get_current_wpm(), '0'), false);

    oled_set_cursor(0, 15);
    oled_write(" wpm", false);

    /* this fixes the screen on and off bug */

  } else if (timer_elapsed32(anim_sleep) > OLED_TIMEOUT) {
    /* clear */
    oled_set_cursor(0, 0);
    oled_write("                                                               "
               "                                                         ",
               false);
    oled_off();
  }
}

static void print_status_narrow(void) {
  /* Print current layer */
  oled_write("LAYER", false);

  oled_set_cursor(0, 6);

  switch (get_highest_layer(layer_state)) {
  case _WORKMAN:
    oled_write("Base ", false);
    break;
  case _QWERTY:
    oled_write("Game ", false);
    break;
  case _NUMBERS:
    oled_write("Nums ", false);
    break;
  case _SYMBOLS:
    oled_write("Symb ", false);
    break;
  case _ADJUST:
    oled_write("Adju ", false);
    break;
  default:
    oled_write("Undef", false);
  }

  /* KEYBOARD PET RENDER START */

  render_luna(0, 13);

  /* KEYBOARD PET RENDER END */
}

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
  return OLED_ROTATION_270;
}

bool oled_task_user(void) {
  /* KEYBOARD PET VARIABLES START */

  current_wpm = get_current_wpm();
  led_usb_state = host_keyboard_led_state();

  /* KEYBOARD PET VARIABLES END */

  if (is_keyboard_master()) {
    print_status_narrow();
  } else {
    print_logo_narrow();
  }
  return false;
}

bool process_record_user(uint16_t keycode, keyrecord_t *record) {
  switch (keycode) {
    /* KEYBOARD PET STATUS START */

  case KC_LCTL:
  case KC_RCTL:
  case LCTL_T(KC_H):
  case RCTL_T(KC_E):
    isSneaking = record->event.pressed;
    break;
  case KC_SPC:
  case RSFT_T(KC_SPC):
    isJumping = record->event.pressed;
    if (isJumping) {
      showedJump = false;
    }
    break;
  case KC_CAPS:
    isBarking = record->event.pressed;
    break;

    /* KEYBOARD PET STATUS END */
  }

  return true;
}
